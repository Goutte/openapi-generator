extends RefCounted
# We class_name it for now (KISS), but eventually I'd like to remove this.
# Not trivial, though, because that means preloads and absolute paths.
class_name {{>partials/api_base_class_name}}


# Base class for all generated API endpoints.
#
# Every property/method defined here may collide with userland,
# so these are all listed and excluded in our CodeGen Java file.
# We want to keep the amount of renaming to a minimum, though.
# Therefore, we use the bee_ prefix, even if awkward.


const DEFAULT_HOST := "localhost"
const HTTP_DEFAULT_PORT := 80
const HTTPS_DEFAULT_PORT := 443
const POLLING_INTERVAL_MS := 500  # milliseconds


# We'll probably only use this for logging
var bee_name := "ApiBee"


# Godot's HTTP Client we are using.
# If none was set (by you), we'll make one.
var bee_client: HTTPClient:
	set(value):
		bee_client = value
	get:
		if not bee_client:
			bee_client = HTTPClient.new()
		return bee_client


# The host to connect to, with or without the scheme.
# Eg: "gitea.com", "https://gitea.com"
# We configure TLS accordingly to the provided scheme, if any.
var bee_host := DEFAULT_HOST:
	set(value):
		if value.begins_with("https://"):
			bee_enable_ssl()
			value = value.substr(8)  # "https://".length() == 8
		elif value.begins_with("http://"):
			bee_disable_ssl()
			value = value.substr(7)  # "http://".length() == 7
		bee_host = value


# Port through which the connection will be established.
# Note: changing the host may change the port as well.
var bee_port := HTTP_DEFAULT_PORT


# @private
var __bee_ssl_enabled := false
var __bee_verify_host := true  # only if ssl enabled


func bee_enable_ssl():
	self.__bee_ssl_enabled = true
	self.bee_port = HTTPS_DEFAULT_PORT


func bee_disable_ssl():
	self.__bee_ssl_enabled = false
	self.bee_port = HTTP_DEFAULT_PORT


func bee_next_loop_iteration():
	return Engine.get_main_loop().process_frame


func bee_connect_client_if_needed(
	on_success: Callable,  # func()
	on_failure: Callable,  # func(error: {{>partials/api_error_class_name}})
	#finally: Callable,
):
	if (
		self.bee_client.get_status() == HTTPClient.STATUS_CONNECTED
		or
		self.bee_client.get_status() == HTTPClient.STATUS_RESOLVING
		or
		self.bee_client.get_status() == HTTPClient.STATUS_CONNECTING
		or
		self.bee_client.get_status() == HTTPClient.STATUS_REQUESTING
		or
		self.bee_client.get_status() == HTTPClient.STATUS_BODY
	):
		on_success.call()

	var connecting := self.bee_client.connect_to_host(
		self.bee_host, self.bee_port,
		self.__bee_ssl_enabled, self.__bee_verify_host
	)
	if connecting != OK:
		var error := {{>partials/api_error_class_name}}.new()
		error.internal_code = connecting
		error.identifier = "apibee.connect_to_host.failure"
		error.message = "%s: failed to connect to `%s' port %d with error %d" % [
			self.bee_name, self.bee_host, self.bee_port, connecting
		]
		on_failure.call(error)
		return

	# Wait until resolved and connected.
	while (
		self.bee_client.get_status() == HTTPClient.STATUS_CONNECTING
		or
		self.bee_client.get_status() == HTTPClient.STATUS_RESOLVING
	):
		self.bee_client.poll()
		print("Connecting...")
		if POLLING_INTERVAL_MS:
			OS.delay_msec(POLLING_INTERVAL_MS)
		await bee_next_loop_iteration()

	if self.bee_client.get_status() != HTTPClient.STATUS_CONNECTED:
		var error := {{>partials/api_error_class_name}}.new()
		error.internal_code = connecting
		error.identifier = "apibee.connect_to_host.wrong_status"
		error.message = "%s: failed to connect to `%s' port %d, with client status %d" % [
			self.bee_name, self.bee_host, self.bee_port, self.bee_client.get_status()
		]
		on_failure.call(error)
		return

	on_success.call()


# @protected
func bee_request(
	method: int,  # one of HTTPClient.METHOD_XXXXX
	path: String,
	query: Dictionary,
	body,  # Variant that will be serialized
	on_success: Callable,  # func(response: Variant, responseCode: int, responseHeaders: Dictionary)
	on_failure: Callable,  # func(error: {{>partials/api_error_class_name}})
):

	bee_request_text(
		method, path, query, body,
		func(responseText, responseCode, responseHeaders):
			var mime: String = responseHeaders['Mime']
			var deserializedResponse: Dictionary
			var denormalizedResponse  # Variant

			if "application/json" == mime:
				var parser := JSON.new()
				var parsing := parser.parse(responseText)
				if OK != parsing:
					var error := {{>partials/api_error_class_name}}.new()
					error.internal_code = parsing
					error.identifier = "apibee.deserialize.cannot_parse_json"
					error.message = "%s: failed to parse JSON at line %d.\n%s" % [
						self.bee_name, parser.get_error_line(), parser.get_error_message()
					]
					on_failure.call(error)
					return
				deserializedResponse = parser.data
				denormalizedResponse = deserializedResponse  # FIXME
			else:
				var error := {{>partials/api_error_class_name}}.new()
				error.internal_code = ERR_INVALID_DATA
				error.identifier = "apibee.deserialize.mime_type_unsupported"
				error.message = "%s: mime type `%s' is not supported (yet)" % [
					self.bee_name, mime
				]
				on_failure.call(error)
				return

			on_success.call(denormalizedResponse, responseCode, responseHeaders)
			,
		func(error):
			on_failure.call(error)
			,
	)


# @protected
func bee_request_text(
	method: int,  # one of HTTPClient.METHOD_XXXXX
	path: String,
	query: Dictionary,
	body,  # Variant that will be serialized
	on_success: Callable,  # func(responseText: String, responseCode: int, responseHeaders: Dictionary)
	on_failure: Callable,  # func(error: {{>partials/api_error_class_name}})
):
	bee_connect_client_if_needed(
		func():
			bee_do_request_text(method, path, query, body, on_success, on_failure)
			,
		func(error):
			on_failure.call(error)
			,
	)


# @protected
func bee_do_request_text(
	method: int,  # one of HTTPClient.METHOD_XXXXX
	path: String,
	query: Dictionary,
	body,  # Variant that will be serialized
	on_success: Callable,  # func(responseText: String, responseCode: int, responseHeaders: Dictionary)
	on_failure: Callable,  # func(error: {{>partials/api_error_class_name}})
):

	# TODO: How can we help users define more / override these?
	# 1. template overrides
	# 2. CLI args
	# 3. YAML Config file
	# 4. class property/method (needed anyway for auth)
	var headers = [
		"User-Agent: Stigmergiac/1.0 (Godot)",
		"Accept: application/json",
		"Content-Type: application/json",
		"api_key: special-key",
	]

	# TODO: Handle other serialization schemes (json+ld, xmlâ€¦)
	var body_normalized = body
	if body is Object:
		if body.has_method('bee_collect_missing_properties'):
			var missing_properties : Array = body.bee_collect_missing_properties()
			if missing_properties:
				var error := {{>partials/api_error_class_name}}.new()
				error.identifier = "apibee.request.body.missing_properties"
				error.message = "%s: `%s' is missing required properties %s." % [
					self.bee_name, body.bee_class_name, missing_properties
				]
				on_failure.call(error)
				return
		if body.has_method('bee_normalize'):
			body_normalized = body.bee_normalize()
	var body_serialized = JSON.stringify(body_normalized)

	var path_queried := path
	var query_string := self.bee_client.query_string_from_dict(query)
	if query_string:
		path_queried = "%s?%s" % [path, query_string]

	var requesting := self.bee_client.request(method, path_queried, headers, body_serialized)
	if requesting != OK:
		var error := {{>partials/api_error_class_name}}.new()
		error.internal_code = requesting
		error.identifier = "apibee.request.failure"
		error.message = "%s: failed to request to path `%s'." % [
			self.bee_name, path
		]
		on_failure.call(error)
		return

	while self.bee_client.get_status() == HTTPClient.STATUS_REQUESTING:
		# Keep polling for as long as the request is being processed.
		self.bee_client.poll()
		print("Requesting...")
		if POLLING_INTERVAL_MS:  # yeah yeah, needs work
			OS.delay_msec(POLLING_INTERVAL_MS)
		await bee_next_loop_iteration()
#		if OS.has_feature("web") or async:

	if not self.bee_client.has_response():
		var error := {{>partials/api_error_class_name}}.new()
		error.identifier = "apibee.request.no_response"
		error.message = "%s: request to `%s' yielded no response whatsoever." % [
			self.bee_name, path
		]
		on_failure.call(error)
		return

	var response_code := self.bee_client.get_response_code()
	var response_headers := self.bee_client.get_response_headers_as_dictionary()
	# FIXME: extract from headers "Content-Type": "application/json; charset=utf-8"
	# This begs for a HttpResponse class ; wait for Godot?
	var encoding := "utf-8"
	var mime := "application/json"
	response_headers['Encoding'] = encoding
	response_headers['Mime'] = mime

	# TODO: cap the size of this, perhaps?
	var response_bytes := PackedByteArray()

	while self.bee_client.get_status() == HTTPClient.STATUS_BODY:
		self.bee_client.poll()
		var chunk = self.bee_client.read_response_body_chunk()
		if chunk.size() == 0:  # Got nothing, wait for buffers to fill a bit.
			if not false:
				OS.delay_usec(POLLING_INTERVAL_MS)
			else:
				await bee_next_loop_iteration()
		else:  # Yummy data has arrived
			response_bytes = response_bytes + chunk

	print("REQUEST")
	print("%s %s" % [method, path_queried])
	print("Headers: %s" % [str(headers)])
	prints(body_serialized)

	prints("RESPONSE CODE:", response_code)
	prints("RESPONSE HEADERS:", response_headers)
	print("RESPONSE SIZE: %d bytes " % response_bytes.size())

	var response_text: String
	if encoding == "utf-8":
		response_text = response_bytes.get_string_from_utf8()
	elif encoding == "utf-16":
		response_text = response_bytes.get_string_from_utf16()
	elif encoding == "utf-32":
		response_text = response_bytes.get_string_from_utf32()
	else:
		response_text = response_bytes.get_string_from_ascii()

	if response_code >= 500:
		var error := {{>partials/api_error_class_name}}.new()
		error.internal_code = ERR_PRINTER_ON_FIRE
		error.identifier = "apibee.response.5xx"
		error.message = "%s: request to `%s' made the server hiccup with a %d." % [
			self.bee_name, path, response_code
		]
		error.message += "\n%s" % [
			bee_format_error_response(response_text)
		]
		on_failure.call(error)
		return
	elif response_code >= 400:
		var error := {{>partials/api_error_class_name}}.new()
		error.identifier = "apibee.response.4xx"
		error.message = "%s: request to `%s' was denied with a %d." % [
			self.bee_name, path, response_code
		]
		error.message += "\n%s" % [
			bee_format_error_response(response_text)
		]
		on_failure.call(error)
		return
	elif response_code >= 300:
		var error := {{>partials/api_error_class_name}}.new()
		error.identifier = "apibee.response.3xx"
		error.message = "%s: request to `%s' was redirected with a %d.  We do not support redirects in that client yet." % [
			self.bee_name, path, response_code
		]
		on_failure.call(error)
		return

	# Should we close ?
	#self.bee_client.close()

	on_success.call(response_text, response_code, response_headers)


func bee_convert_http_method(method: String) -> int:
	match method:
		'GET': return HTTPClient.METHOD_GET
		'POST': return HTTPClient.METHOD_POST
		'PUT': return HTTPClient.METHOD_PUT
		'PATCH': return HTTPClient.METHOD_PATCH
		'DELETE': return HTTPClient.METHOD_DELETE
		'CONNECT': return HTTPClient.METHOD_CONNECT
		'HEAD': return HTTPClient.METHOD_HEAD
		'MAX': return HTTPClient.METHOD_MAX
		'OPTIONS': return HTTPClient.METHOD_OPTIONS
		'TRACE': return HTTPClient.METHOD_TRACE
		_:
			printerr("%s: unknown http method `%s`, assuming GET." % [
				self.bee_name, method
			])
			return HTTPClient.METHOD_GET


func bee_urlize_path_param(anything) -> String:
	var serialized := bee_escape_path_param(str(anything))
	return serialized


func bee_escape_path_param(value: String) -> String:
	# TODO: escape for URL
	return value


func bee_format_error_response(response: String) -> String:
	# TODO: handle other (de)serialization schemes
	var parser := JSON.new()
	var parsing := parser.parse(response)
	if OK != parsing:
		return response
	if not (parser.data is Dictionary):
		return response
	var s := "ERROR"
	if parser.data.has("code"):
		s += " %d" % parser.data['code']
	if parser.data.has("message"):
		s += "\n%s" % parser.data['message']
	else:
		return response
	return s
